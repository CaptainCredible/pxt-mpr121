{"entries":[{"timestamp":1756066915667,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":294,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":107,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":89,"length1":80,"diffs":[[1,"        \"radio\": \"*\",\n"]]},{"start1":201,"length1":45,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":228,"length1":35,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"pxt-mpr121.ts","value":"// mpr121 touch blocks modified from makerbit\n\nconst enum TouchSensor {\n    T11 = 0b100000000000,\n    T10 = 0b010000000000,\n    T9 = 0b001000000000,\n    T8 = 0b000100000000,\n    T7 = 0b000010000000,\n    T6 = 0b000001000000,\n    T5 = 0b000000100000,\n    T4 = 0b000000010000,\n    T3 = 0b000000001000,\n    T2 = 0b000000000100,\n    T1 = 0b000000000010,\n    T0 = 0b000000000001,\n    //% block=\"any\"\n    Any = 1 << 30,\n}\n\nconst enum TouchAction {\n    //% block=\"touched\"\n    Touched = 0,\n    //% block=\"released\"\n    Released = 1,\n}\n\n//% color=#0fbc11 icon=\"\\u272a\" block=\"mpr121\"\n//% category=\"mpr121\"\nnamespace makerbit {\n    const MPR121_ADDRESS = 0x5A;\n    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50;\n\n    class TouchHandler {\n        sensor: TouchSensor;\n        handler: () => void;\n\n        constructor(\n            sensor: TouchSensor,\n            handler: () => void\n        ) {\n            this.sensor = sensor;\n            this.handler = handler;\n        }\n\n        onEvent(sensor: TouchSensor) {\n            if (sensor === this.sensor || TouchSensor.Any === this.sensor) {\n                this.handler();\n            }\n        }\n    }\n\n    interface TouchState {\n        touchStatus: number;\n        eventValue: number;\n        hasNewTouchedEvent: boolean;\n        onTouched: TouchHandler[];\n        onReleased: TouchHandler[];\n    }\n\n    let touchState: TouchState;\n\n    /**\n     * Initialize the touch controller.\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=\"makerbit_touch_init\" block=\"initialize touch\"\n    //% weight=70\n    function initTouchController(): void {\n        if (!!touchState) {\n            return;\n        }\n\n        touchState = {\n            touchStatus: 0,\n            eventValue: 0,\n            hasNewTouchedEvent: false,\n            onTouched: [],\n            onReleased: [],\n        };\n\n        const addr = MPR121_ADDRESS;\n        mpr121.reset(addr);\n\n        // Stop capture\n        mpr121.stop(addr);\n\n        // Input filter for rising state\n        mpr121.configure(addr, mpr121.Config.MHDR, 0x01);\n        mpr121.configure(addr, mpr121.Config.NHDR, 0x01);\n        mpr121.configure(addr, mpr121.Config.NCLR, 0x10);\n        mpr121.configure(addr, mpr121.Config.FDLR, 0x20);\n\n        // Input filter for falling state\n        mpr121.configure(addr, mpr121.Config.MHDF, 0x01);\n        mpr121.configure(addr, mpr121.Config.NHDF, 0x01);\n        mpr121.configure(addr, mpr121.Config.NCLF, 0x10);\n        mpr121.configure(addr, mpr121.Config.FDLF, 0x20);\n\n        // Input filter for touched state\n        mpr121.configure(addr, mpr121.Config.NHDT, 0x01);\n        mpr121.configure(addr, mpr121.Config.NCLT, 0x10);\n        mpr121.configure(addr, mpr121.Config.FDLT, 0xff);\n\n        // Unused proximity sensor filter\n        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0f);\n        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0f);\n        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00);\n        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00);\n        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01);\n        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01);\n        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xff);\n        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xff);\n        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00);\n        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00);\n        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00);\n\n        // Debounce configuration (used primarily for interrupts)\n        mpr121.configure(addr, mpr121.Config.DTR, 0x11);\n\n        // Electrode clock frequency etc\n        mpr121.configure(addr, mpr121.Config.AFE1, 0xff);\n        mpr121.configure(addr, mpr121.Config.AFE2, 0x30);\n\n        // Enable autoconfiguration / calibration\n        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00);\n        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00);\n\n        // Tuning parameters for the autocalibration algorithm\n        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00);\n        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00);\n        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00);\n\n        // Default sensitivity thresholds\n        mpr121.configureThresholds(addr, 60, 20);\n\n        // Restart capture and stop repeated writing\n        mpr121.start(addr);\n\n        background.schedule(detectAndNotifyTouchEvents, background.Thread.UserCallback, background.Mode.Repeat, TOUCH_STATUS_PAUSE_BETWEEN_READ);\n    }\n\n    function detectAndNotifyTouchEvents() {\n        const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS);\n\n        if (touchStatus != touchState.touchStatus) {\n            const previousState = touchState.touchStatus;\n            touchState.touchStatus = touchStatus;\n\n            for (\n                let touchSensorBit = 1;\n                touchSensorBit <= 2048;\n                touchSensorBit <<= 1\n            ) {\n                // Raise event when touch ends\n                if ((touchSensorBit & touchStatus) === 0) {\n                    if (!((touchSensorBit & previousState) === 0)) {\n                        touchState.eventValue = touchSensorBit;\n                        touchState.onReleased.forEach((th) => { th.onEvent(touchSensorBit) });\n                    }\n                }\n\n                // Raise event when touch starts\n                if ((touchSensorBit & touchStatus) !== 0) {\n                    if (!((touchSensorBit & previousState) !== 0)) {\n                        touchState.eventValue = touchSensorBit;\n                        touchState.hasNewTouchedEvent = true;\n                        touchState.onTouched.forEach((th) => { th.onEvent(touchSensorBit) });\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Do something when a touch sensor is touched or released.\n     * @param sensor the touch sensor to be checked, eg: TouchSensor.T5\n     * @param action the trigger action\n     * @param handler body code to run when the event is raised\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=makerbit_touch_on_touch_sensor\n    //% block=\"on touch sensor | %sensor | %action\"\n    //% sensor.fieldEditor=\"gridpicker\" sensor.fieldOptions.columns=6\n    //% sensor.fieldOptions.tooltips=\"false\"\n    //% weight=65\n    export function onTouch(\n        sensor: TouchSensor,\n        action: TouchAction,\n        handler: () => void\n    ) {\n        initTouchController();\n        if (action === TouchAction.Touched) {\n            touchState.onTouched.push(new TouchHandler(sensor, handler));\n        }\n        else {\n            touchState.onReleased.push(new TouchHandler(sensor, handler));\n        }\n    }\n\n    /**\n     * Returns the sensor index of the last touch event that was received.\n     * It could be either a sensor touched or released event.\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=makerbit_touch_current_touch_sensor\n    //% block=\"touch sensor\"\n    //% weight=50\n    export function touchSensor(): number {\n        initTouchController();\n        if (touchState.eventValue !== 0) {\n            return getSensorIndexFromSensorBitField(touchState.eventValue);\n        } else {\n            return 0;\n        }\n    }\n\n    function getSensorIndexFromSensorBitField(touchSensorBit: TouchSensor) {\n        if (touchSensorBit === TouchSensor.Any) {\n            return TouchSensor.Any;\n        }\n\n        let bit = TouchSensor.T5;\n        for (let sensorIndex = 5; sensorIndex <= 16; sensorIndex++) {\n            if ((bit & touchSensorBit) !== 0) {\n                return sensorIndex; // return first hit\n            }\n            bit >>= 1;\n        }\n        return 0;\n    }\n\n    function getTouchSensorFromIndex(index: number): TouchSensor {\n        if (5 <= index && index <= 16) {\n            return TouchSensor.T5 >> (index - 5);\n        } else if (index === TouchSensor.Any) {\n            return TouchSensor.Any;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns true if a specific touch sensor is currently touched. False otherwise.\n     * @param sensor the touch sensor to be checked, eg: TouchSensor.T5\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=makerbit_touch_is_touch_sensor_touched\n    //% block=\"touch sensor | %sensor | is touched\"\n    //% sensor.fieldEditor=\"gridpicker\" sensor.fieldOptions.columns=6\n    //% sensor.fieldOptions.tooltips=\"false\"\n    //% weight=40\n    //% blockHidden=true\n    export function isSensorTouched(sensor: TouchSensor): boolean {\n        initTouchController();\n        if (sensor === TouchSensor.Any) {\n            return touchState.touchStatus !== 0;\n        } else {\n            return (touchState.touchStatus & sensor) !== 0;\n        }\n    }\n\n    /**\n     * Turns a TouchSensor into its index value.\n     * @param sensor the touch sensor, eg: TouchSensor.T5\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=makerbit_touch_sensor_index\n    //% block=\"%touchSensorIndex\"\n    //% sensor.fieldEditor=\"gridpicker\" sensor.fieldOptions.columns=6\n    //% sensor.fieldOptions.tooltips=\"false\"\n    //% blockHidden=true\n    export function touchSensorIndex(sensor: TouchSensor): number {\n        return getSensorIndexFromSensorBitField(sensor);\n    }\n\n    /**\n     * Returns true if a specific touch sensor is currently touched. False otherwise.\n     * @param sensorIndex the touch sensor index to be checked\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=\"makerbit_touch_is_touch_sensor_index_touched\"\n    //% block=\"touch sensor | %sensorIndex=makerbit_touch_sensor_index | is touched\"\n    //% weight=42\n    export function isTouched(sensorIndex: number): boolean {\n        return isSensorTouched(getTouchSensorFromIndex(sensorIndex));\n    }\n\n    /**\n     * Returns true if any sensor was touched since the last call of this function. False otherwise.\n     */\n    //% subcategory=\"Touch\"\n    //% blockId=makerbit_touch_was_any_sensor_touched\n    //% block=\"any touch sensor was touched\"\n    //% weight=41\n    export function wasTouched(): boolean {\n        initTouchController();\n        if (touchState.hasNewTouchedEvent) {\n            touchState.hasNewTouchedEvent = false;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Communication module for MPR121 capacitive touch sensor controller\n    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf\n    export namespace mpr121 {\n        /*\n        export const enum CalibrationLock {\n          BaselineTrackingOn = 0b00,\n          BaselineTrackingOff = 0b01,\n          BaselineTrackingAndInitializeFirst5MSB = 0b10,\n          BaselineTrackingAndInitialize = 0b11,\n        }\n        */\n        const CalibrationLock_BaselineTrackingAndInitialize = 0b11;\n\n        /*\n        export const enum Proximity {\n          DISABLED = 0b00,\n          ELE0_TO_1 = 0b01,\n          ELE_0_TO_3 = 0b10,\n          ELE_0_TO_11 = 0b11,\n        }\n        */\n        const Proximity_DISABLED = 0b00;\n\n        /*\n        export const enum Touch {\n          DISABLED = 0b0000,\n          ELE_0 = 0b0001,\n          ELE_0_TO_1 = 0b0010,\n          ELE_0_TO_2 = 0b0011,\n          ELE_0_TO_3 = 0b0100,\n          ELE_0_TO_4 = 0b0101,\n          ELE_0_TO_5 = 0b0110,\n          ELE_0_TO_6 = 0b0111,\n          ELE_0_TO_7 = 0b1000,\n          ELE_0_TO_8 = 0b1001,\n          ELE_0_TO_9 = 0b1010,\n          ELE_0_TO_10 = 0b1011,\n          ELE_0_TO_11 = 0b1100,\n        }\n        */\n        const Touch_ELE_0_TO_11 = 0b1100;\n\n        export const enum Config {\n            MHDR = 0x2b,\n            NHDR = 0x2c,\n            NCLR = 0x2d,\n            FDLR = 0x2e,\n            MHDF = 0x2f,\n            NHDF = 0x30,\n            NCLF = 0x31,\n            FDLF = 0x32,\n            NHDT = 0x33,\n            NCLT = 0x34,\n            FDLT = 0x35,\n            MHDPROXR = 0x36,\n            NHDPROXR = 0x37,\n            NCLPROXR = 0x38,\n            FDLPROXR = 0x39,\n            MHDPROXF = 0x3a,\n            NHDPROXF = 0x3b,\n            NCLPROXF = 0x3c,\n            FDLPROXF = 0x3d,\n            NHDPROXT = 0x3e,\n            NCLPROXT = 0x3f,\n            FDLPROXT = 0x40,\n            E0TTH = 0x41,\n            E0RTH = 0x42,\n            // E1TTH = 0x43,\n            // E1RTH = 0x44,\n            // E2TTH = 0x45,\n            // E2RTH = 0x46,\n            // E3TTH = 0x47,\n            // E3RTH = 0x48,\n            // E4TTH = 0x49,\n            // E4RTH = 0x4a,\n            // E5TTH = 0x4b,\n            // E5RTH = 0x4c,\n            // E6TTH = 0x4d,\n            // E6RTH = 0x4e,\n            // E7TTH = 0x4f,\n            // E7RTH = 0x50,\n            // E8TTH = 0x51,\n            // E8RTH = 0x52,\n            // E9TTH = 0x53,\n            // E9RTH = 0x54,\n            // E10TTH = 0x55,\n            // E10RTH = 0x56,\n            // E11TTH = 0x57,\n            // E11RTH = 0x58,\n            // E12TTH = 0x59,\n            // E12RTH = 0x5a,\n            DTR = 0x5b,\n            AFE1 = 0x5c,\n            AFE2 = 0x5d,\n            ECR = 0x5e,\n            // CDC0 = 0x5f,\n            // CDC1 = 0x60,\n            // CDC2 = 0x62,\n            // CDC4 = 0x63,\n            // CDC5 = 0x64,\n            // CDC6 = 0x65,\n            // CDC7 = 0x66,\n            // CDC8 = 0x67,\n            // CDC9 = 0x68,\n            // CDC10 = 0x69,\n            // CDC11 = 0x6a,\n            // CDC12 = 0x6b,\n            // CDT_0_1 = 0x6c,\n            // CDT_2_3 = 0x6d,\n            // CDT_4_5 = 0x6e,\n            // CDT_6_7 = 0x6f,\n            // CDT_8_9 = 0x70,\n            // CDT_10_11 = 0x71,\n            // CDT_12 = 0x72,\n            // GPIO_CTL0 = 0x73,\n            // GPIO_CTL1 = 0x74,\n            // GPIO_DIR = 0x76,\n            // GPIO_EN = 0x77,\n            // GPIO_SET = 0x78,\n            // GPIO_CLR = 0x79,\n            // GPIO_TOG = 0x7a,\n            AUTO_CONFIG_0 = 0x7b,\n            AUTO_CONFIG_1 = 0x7c,\n            AUTO_CONFIG_USL = 0x7d,\n            AUTO_CONFIG_LSL = 0x7e,\n            AUTO_CONFIG_TL = 0x7f,\n        }\n\n        function writeCommandData(\n            address: number,\n            command: number,\n            data: number\n        ): void {\n            const commandDataBuffer = pins.createBuffer(\n                pins.sizeOf(NumberFormat.UInt16BE)\n            );\n            commandDataBuffer.setNumber(\n                NumberFormat.UInt16BE,\n                0,\n                (command << 8) | data\n            );\n            pins.i2cWriteBuffer(address, commandDataBuffer);\n        }\n\n        function writeCommand(address: number, command: number): void {\n            const commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE));\n            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command);\n            pins.i2cWriteBuffer(address, commandBuffer);\n        }\n\n        export function configure(\n            address: number,\n            register: Config,\n            value: number\n        ): void {\n            writeCommandData(address, register, value);\n        }\n\n        export function configureThresholds(\n            address: number,\n            touch: number,\n            release: number,\n        ): void {\n            for (let i = 0; i < 12; i++) {\n                configure(address, Config.E0TTH + i * 2, touch);\n                configure(address, Config.E0RTH + i * 2, release);\n            }\n        }\n\n        export function reset(address: number): void {\n            writeCommandData(address, 0x80, 0x63);\n            basic.pause(30);\n        }\n\n        export function stop(address: number): void {\n            writeCommandData(address, Config.ECR, 0x0);\n        }\n\n        export function start(\n            address: number\n        ): void {\n            writeCommandData(\n                address,\n                Config.ECR,\n                (CalibrationLock_BaselineTrackingAndInitialize << 6) | (Proximity_DISABLED << 4) | Touch_ELE_0_TO_11);\n        }\n\n        export function readTouchStatus(address: number): number {\n            writeCommand(address, 0x0);\n            return pins.i2cReadNumber(address, NumberFormat.UInt16LE);\n        }\n    }\n}\n"}]},{"timestamp":1756067510204,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":824,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block><block type=\"makerbit_touch_on_touch_sensor\" x=\"415\" y=\"227\"><field name=\"sensor\">TouchSensor.Any</field><field name=\"action\">TouchAction.Touched</field></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":69,"length1":59,"diffs":[[1,"\t\n})\nbasic.forever(function () {\n\t\n})\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":311,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"edited","filename":"pxt-mpr121.ts","patch":[{"start1":72,"length1":302,"diffs":[[1,"    T11 = 0b100000000000,\n    T10 = 0b010000000000,\n    T9 = 0b001000000000,\n    T8 = 0b000100000000,\n    T7 = 0b000010000000,\n    T6 = 0b000001000000,\n    T5 = 0b000000100000,\n    T4 = 0b000000010000,\n    T3 = 0b000000001000,\n    T2 = 0b000000000100,\n    T1 = 0b000000000010,\n    T0 = 0b000000000001,\n"]]}]}]},{"timestamp":1756067861773,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"makerbit.onTouch(TouchSensor.Any, TouchAction.Touched, function () {\n    serial.writeValue(\"touched\", makerbit.touchSensor())\n})"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":217,"length1":0,"diffs":[[1,"        \"main.blocks\",\n"]]}]},{"type":"edited","filename":"pxt-mpr121.ts","patch":[{"start1":7284,"length1":192,"diffs":[[1,"        if (touchSensorBit === TouchSensor.Any) {\n            return TouchSensor.Any;\n"]]},{"start1":7380,"length1":61,"diffs":[[1,"\n        let bit = TouchSensor.T5;\n        for (let sensorIndex = 5; sensorIndex <= 16; sensorIndex++) {\n            if ((bit & touchSensorBit) !== 0) {\n                return sensorIndex; // return first hit\n            }\n            bit >>= 1;\n        }\n        return 0;\n"]]},{"start1":7728,"length1":91,"diffs":[[1,"        if (5 <= index && index <= 16) {\n            return TouchSensor.T5 >> (index - 5);\n"]]}]},{"type":"removed","filename":"main.blocks","value":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"175\" y=\"139\"><statement name=\"HANDLER\"><block type=\"device_show_leds\"><field name=\"LEDS\">`\n        . . . . . \n        . . # . . \n        . . . . . \n        . . . . . \n        . . . . .\n        `</field></block></statement></block><block type=\"makerbit_touch_on_touch_sensor\" x=\"415\" y=\"227\"><field name=\"sensor\">TouchSensor.Any</field><field name=\"action\">TouchAction.Touched</field><statement name=\"HANDLER\"><block type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">touched</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"makerbit_touch_current_touch_sensor\"></block></value></block></statement></block></xml>"}]},{"timestamp":1756068434414,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":257,"length1":43,"diffs":[[1,"        \"pxt-mpr121.ts\"\n"]]},{"start1":288,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt-mpr121.ts","patch":[{"start1":1430,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":6026,"length1":0,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":6830,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":8026,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":8726,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":9269,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]},{"start1":9719,"length1":6,"diffs":[[1,"    //% subcategory=\"Touch\"\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"},{"type":"added","filename":"main.py","value":"\n"}]}],"snapshots":[{"timestamp":1756066915666,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"touch\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1756068631805}